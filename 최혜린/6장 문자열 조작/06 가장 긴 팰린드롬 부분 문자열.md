## 풀이

- 어떻게 푸는지 감이 안온다...그래서 힌트들 확인 중
- How can we reuse a previously computed palindrome to compute a larger palindrome?
    - 이전에 계산된 팰린드롬을 어떻게 더 큰 팰린드롬을 계산하는데 사용할 수 있을까?
        - 현재 가지고 있는 문자열이 팰린드롬이라면 양 옆에 동일한 character를 붙이면 더 큰 팰린드롬이 되지 않을까?
- brute force로 모든 조합을 구하는 방법을 생각은 해봤지만 조합을 구하는 O(n^2), 팰린드롬을 체크하는 O(n)으로 인해 O(n^3) 시간 복잡도를 가지게 된다.
- 이때 팰린드롬 체크하는 과정을 O(1)로 줄일 수 있는 방법을 고안해내야한다!
- 그래도...문제풀이를 알아내기가 어려워서 처음으로 못풀고 풀이를 봤다ㅜㅜㅜ

## 가능한 풀이

### 중앙을 중심으로 확장하는 풀이

- 여러개의 입력 문자열이 있을 때 서로 공통된 가장 긴 부분 문자열을 찾는 **최장 공통 부분 문자열**이라는 문제와 동일한 유형
- DP로 풀이가 가능하지만 풀이가 직관적이지 않음 그리고 실행 속도가 느림
- 따라서 **투 포인터가 중앙을 중심으로 확장하는 방식**으로 풀이

```python
# 짝수, 홀수 팰린드롬을 각각 판정하기 위하여 두 칸, 세 칸짜리 투 포인터를 두 개씩 움직인다
class Solution:
    def longestPalindrome(self, s: str) -> str:
            
        def expand(left, right):
            while left >= 0 and right < len(s) and s[left] == s[right]:
                left -= 1
                right += 1

            return s[left + 1:right]
        
        # 예외처리
        if len(s) < 2 or s == s[::-1]:
            return s
        
        result = ''
        
        for idx in range(len(s) - 1):
            result = max(result, expand(idx, idx + 1), expand(idx, idx + 2), key = len)
            
        return result
```

- 두 개의 슬라이딩 윈도우를 생성, 하나는 길이가 2, 나머지는 길이가 3(짝, 홀)
- 0부터 마지막에서 두번째 element까지 for문을 통해서 슬라이딩 윈도우가 왼쪽에서 오른쪽으로 한칸씩 이동함
- 이때 각 슬라이딩 윈도우가 팰린드롬인지 확인하고 만약에 팰린드롬이라면 가운데를 중심으로 양 옆으로 확장시킴
- 조건을 만족시키지 못한 경우 while문을 빠져나오기 때문에 left에는 빠진 1을 더해주고 right에는 더해준 1을 빼줘야하는데 slicing을 할 때 오른쪽 index는 포함되지 않기 때문에 s[left + 1:right]를 리턴해줌

## 유니코드와 UTF-8

- 초반의 **아스키** 인코딩 방식은 1바이트로 모든 문자를 표현함. 그 중 1비트는 체크섬으로 제외하고 나머지 7비트, 즉 128글자로 모든 글자를 표현함
- 한글이나 한자같은 문자는 2개 이상의 특수문자를 합쳐서 표현 → 제대로 표현 x
- 해결하기 위하여 2-4바이트 공간에 여유있게 문자를 할당하기 위한 방식 = **유니코드**
- 하지만 기존에 1바이트로도 표현이 가능한 영어를 2바이트로 표현하기 때문에 공간의 낭비 발생
- 또 이를 해결하기 위한 가변 길이 문자 인코딩 방식이 **UTF-8**